A - Introduction
Networking involves connecting two or more computing devices to share data. Networks combine hardware and software to enable this interconnection.

In simple terms, a network is a set of computers and other hardware components connected by communication channels, allowing for the sharing of resources and information. Our Linux servers will therefore aim to communicate and be accessible via multiple network protocols.

We will introduce network concepts in order to better understand the configurations needed on our Linux servers.

B - TCP/IP Network
TCP/IP stands for Transmission Control Protocol / Internet Protocol. It is a set of protocols that define how two or more computers can communicate. A protocol is a set of rules describing how data is transmitted.

TCP/IP is an open standard and can be implemented on any computer with the appropriate physical components. It includes many protocols providing different essential functionalities for data exchange.

A related protocol is UDP (User Datagram Protocol), which also operates over IP. The main difference is that TCP is connection-oriented, while UDP is connectionless. With TCP, a session is established between hosts and the transfer of data is guaranteed.

With UDP, each data packet is sent without receipt verification or retransmission at the network level.

TCP uses port numbers to identify the receiving process and sequence numbers to track the order of packets, ensuring that data is received in the correct order.
UDP does not use sequencing. Packets are sent independently, and their reassembly occurs at the receiving application level. The protocol cannot determine which packet should arrive first. Unprocessable packets are simply discarded.
UDP is very popular due to its speed and efficiency: it does not need to establish a connection before sending packets, which reduces latency and speeds up data transmission. It also does not require sequencing or acknowledgments, saving time.
C - OSI Model
c.1 - Presentation
In networks, the data transmitted between devices is organized into packets, and the transmission process is called traffic. Packets are transmitted according to protocols, which are systems of rules governing communication.

Protocols are organized in layers to structure network communication.

The OSI model (Open Systems Interconnection) is a standard that divides all protocols into 7 layers. These layers govern the transmission of packets, from hardware components (such as network cards) to the applications using the network, like web browsers, Telegram, Google, or Facebook.

c.2 - The layers of the OSI model
In the table below, the different layers of the OSI model:


Level	Layer Name
7	Application
6	Presentation
5	Session
4	Transport
3	Network
2	Data link
1	Physical
The material layers correspond to the lower layers, while the software layers correspond to the upper layers. Each upper layer is dependent on those that precede it.

Here is a detailed description of the 7 OSI layers:

Physical layer (1) This is the lowest layer, the farthest from the user. It converts bits into electrical, optical, or radio signals.
This layer also defines:

Voltage levels and timing changes.
Physical data rates and transmission distances.
Channel access and physical connectors.
Pin layout, cable specifications, signal timing, and frequency of wireless devices.

Data Link Layer (2) Controlled by the network device driver, this layer ensures control and protection of the Physical layer. It detects and corrects, if possible, transmission errors.
The Data Link layer also manages MAC addresses, corresponding to the physical addresses of network cards.

Network Layer (3) The IP protocol operates at this level. The network layer:

Segment the data and limit the size of packets.
Determine the path or route between devices.
Encapsulate the data with source and destination information.
Interact with routers to route the packets.
Another important protocol at this level is ICMP (Internet Control Message Protocol), used to report errors or send operational information, such as with the ping command.

However, this layer does not guarantee the correct delivery of packets nor an error report, this role being supported by the Transport layer.

Transport layer (4) This layer provides protocols to ensure the reliability of transmission:

TCP (Transmission Control Protocol) follows the sequence of packets, detects and reports errors, and retransmits undelivered packets.
UDP (User Datagram Protocol) does not guarantee delivery, but allows for faster transmission.
TCP is used for applications requiring reliability, while UDP is preferred for streaming or real-time applications.

Session Layer (5) It maintains communication between connections, manages acknowledgments, ensures fault tolerance, and groups messages into unique packets.

Presentation layer (6) This layer transforms the data so that it is readable by the Application layer, by converting it into a standard format.

Application layer (7) The layer closest to the user, where most of the protocols used by end applications operate. Examples :

HTTP / HTTPS for web servers.
FTP for file transfer.
SSH for secure sessions.
These protocols will be detailed in the following chapters.

We can therefore make a comparison between the OSI and TCP/IP models:


Layer	OSI Model	TCP/IP Stack
7	Application	Application
6	Presentation	Application
5	Session	Application
4	Transport	Transport
3	Network	Internet
2	Data link	Network Interface
1	Physical	Network Interface
The main differences between the OSI and TCP/IP models are as follows:

The Application, Presentation, and Session layers have been merged into a single Application layer in TCP/IP.
The Physical and Data Link layers are also grouped together.
In TCP/IP, the boundaries between the layers are not as rigid as in the OSI model, and the functions do not necessarily correspond directly to those of the OSI model.

Knowing the layers of a network model remains useful for troubleshooting: by identifying the layer where connectivity is functioning, it is easier to narrow down the investigation to the other layers.

c.3 - IP Address
The Internet Protocol (IP) is used by private and public networks to enable communication between devices. An IP address is a unique identifier assigned to a device connected to a network.

There are two types of IP addressing standards: IPv4 and IPv6.

IPv4 is the most commonly used standard in businesses. IPv4 addresses are encoded on 4 bytes (32 bits).
IPv6 uses 16 bytes (128 bits).
Each byte can be represented in binary or in dotted decimal (decimal notation with dots separating the bytes). For example, an IPv4 address in binary:

11000000.10101000.01100100.00000001
Translates to decimal pointed by :

192.168.100.1
This notation is much more readable and is the one generally used when working with IP addresses via an Internet Service Provider (ISP).

Conversion from decimal to binary


128	64	32	16	8	4	2	1
2⁷	2⁶	2⁵	2⁴	2³	2²	2¹	2⁰
The numbers in the table are noted this way because each byte of an IP address is made up of 8 bits. In binary, a "bit" can only have two values, 0 or 1. To convert to binary, you need to calculate how many of each number in the segment of the table above, from left to right, corresponds to the decimal number you have for the IP address, also from left to right.

Let's take our IP address above, 192.168.100.1 and convert it to binary.

To convert 192 to binary, we can only have 128 according to our table, which we will subtract from 192. We are left with a remainder of 64.

Once we know that the number corresponds to a value in the table above, we mark it either with a 1 for yes or a 0 for no.

For our example, we had 64, in which the 64 from the table indeed fits with a remainder of 0.

Therefore, our conversion would look like this:


128	64	32	16	8	4	2	1
1	1	0	0	0	0	0	0
Thus 192 in binary is written as 11000000.

Moving on to 168, we continue with the same formula:

128 goes into 168 with a remainder of 40.

64 does not go with 40 because 40 is smaller, but 32 will fit perfectly with a remainder of 8.

8 does not go with 16 because it is smaller, but goes with 8 for a remainder of 0.

Our conversion for 168 will therefore give:


128	64	32	16	8	4	2	1
1	0	1	0	1	0	0	0
Thus 168 in binary is written as 10101000. After the entire conversion, we have 11000000.10101000.01100100.00000001. This conversion will greatly help in understanding subnets and subnet masks.

c.4 - Classes of IP Addresses
Historically, IP addresses (using the IPv4 standard) were divided into 5 classes:

Class A
Class B
Class C
Class D
Class E
They are defined as follows:


Class	Start address	End Address
A	0.0.0.0	127.255.255.255
B	128.0.0.0	191.255.255.255
C	192.0.0.0	223.255.255.255
D	224.0.0.0	239.255.255.255
E	240.0.0.0	255.255.255.255
Each IP class is assigned to the Internet as such:


Class	Usage
A	This class is designed to be used in very large companies like [Google]
B	This one is designed to be used in medium-sized companies
C	Class used in small businesses.
D	Class not used in the public sector but rather reserved for multicast addressing
E	This class is also not used in the public sector, being rather reserved for scientific studies
With the advent of cloud and new technologies, the classic IP addressing scheme is becoming less and less used and is tending to be replaced by CIDR (Classless Inter-Domain Routing) notation. However, the old IP classes are still commonly used in businesses to standardize the use of IP addresses. For example, class C is very common in local or internal networks.

c.5 - IP Addressing
Every host on an IP network is assigned a network number, whether on the Internet or on a private network. IP addressing belongs to layer 3 of the OSI model.

The network numbering allows hosts (or peers) to communicate with each other. Hosts sharing a network can be computers located in the same office, home, or within an entire company.

The addressing scheme is essential: without it, no communication is possible, as it provides a unique identification for each endpoint of the connection.

IP addresses are composed of four octets (32 bits for IPv4) and are typically represented in dotted decimal notation:

xxxx.xxxx.xxxx.xxxx
where each xxxx is a number between 0 and 255. Example: 192.168.1.13

c.6 - Subnet Mask
A subnet mask is used to distinguish the network part and the host part of an IP address. It "masks" the host bits, leaving only the bits of the network ID visible, and allows for defining the size of the network.

A subnet mask can be represented in binary, with all 1s on the left and all 0s on the right.

The simplest way to know your subnet mask on Linux is to run the command ip addr, which displays your IP address as well as the subnet mask, often in CIDR notation.

ip addr
Output display:

1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: mtu 9001 qdisc mq state UP group default qlen 1000 link/ether 06:43:eb:74:5c:c6 brd ff:ff:ff:ff:ff:ff inet 172.31.24.148/20 brd 172.31.31.255 scope global dynamic eth0 valid_lft 3587sec preferred_lft 3587sec inet6 fe80::443:ebff:fe74:5cc6/64 scope link valid_lft forever preferred_lft forever

We can notice that we have two network interfaces lo and eth0:

The network card eth0 has the IP address 172.31.24.148/20.

/20 thus represents the subnet mask.

20 is a CIDR notation for the subnet mask.

The CIDR notation of 172.31.24.148/20 represents the number of network bits in the IP address.

CIDR stands for Classless Inter-Domain Routing, which is an IP addressing scheme that replaces the old class-based system of A, B, and C. CIDR allows for variable-length subnet masks.

CIDR has replaced the previous system based on fixed-size network classes and has gained popularity due to its flexibility and efficiency. The CIDR mask /20 can simply be written as 11111111.11111111.11110000.00000000, which gives us in decimal conversion 255.255.240.0, which is the network mask to which our Linux server belongs.

11111111.11111111.11110000.00000000 means that the 1s correspond to the network address, and the 0s represent the number of available hosts on our network.



Soit une adresse IP avec sa notation CIDR 172.168.2.1/25.

With the tables presented, give the binary notation of the IP address above.

10101100.10101000.00000010.00000001
Calculation Details

First octet :

10101100 : 172 - 128 or (2^7) = 44
10101100 : 44 - 32 or (2^5) = 12
10101100 : 12 - 8 or (2^3) = 4
10101100 : 4 - 4(2^3) = 0
Second octet :

10101000 : 168 - 128 or (2^7) = 40
10101000 : 40 - 32 or (2^5) = 8
10101000 : 8 - 8 or (2^3) = 0
Third octet :

00000010 : 2 - 2 or (2^1) = 0
Fourth octet :

00000001 : 1 - 1 or (2^0) = 0
Provide the binary and decimal notation of the subnet mask using the conversion table

# Binary
11111111.11111111.11111111.10000000

# Decimal
255.255.255.128 or 0.0.0.128 (Wildcard Bits)
How many theoretical addresses will be available for this network?

126 hosts

c.7 - Sockets and Port Numbers
Although the IP address provides the connection to the correct machine, it cannot distinguish between the different services required. The port is used to distinguish the application. It is a value between 0 and 65535. The combination of the IP address, the port, and the protocol is called a socket and must be unique for each service.

The 1000 first ports are reserved for system applications, and under Linux, they can normally be used by a daemon/an application with superuser privileges. Some are defined in RFC 1340, and others are defined by IANA. The details of the reserved ports are listed on most Linux systems in the file /etc/services.

cat /etc/services
Output display:

# Network services, Internet style
#
# Note that it is presently the policy of IANA to assign a single well-known
# port number for both TCP and UDP; hence, officially ports have two entries
# even if the protocol doesn't support UDP operations.
#
# Updated from https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml.
#
# New ports will be added on request if they have been officially assigned
# by IANA and used in the real-world or are needed by a debian package.
# If you need a huge list of used numbers please install the nmap package.

tcpmux          1/tcp                           # TCP port service multiplexer
echo            7/tcp
echo            7/udp
discard         9/tcp           sink null
discard         9/udp           sink null
systat          11/tcp          users
daytime         13/tcp
daytime         13/udp
netstat         15/tcp
qotd            17/tcp          quote
chargen         19/tcp          ttytst source
chargen         19/udp          ttytst source
ftp-data        20/tcp
ftp             21/tcp
fsp             21/udp          fspd
ssh             22/tcp                          # SSH Remote Login Protocol
telnet          23/tcp
smtp            25/tcp          mail
time            37/tcp          timserver
time            37/udp          timserver
whois           43/tcp          nicname
tacacs          49/tcp                          # Login Host Protocol (TACACS)
tacacs          49/udp
domain          53/tcp                          # Domain Name Server
domain          53/udp
bootps          67/udp
bootpc          68/udp
tftp            69/udp
gopher          70/tcp                          # Internet Gopher
finger          79/tcp
http            80/tcp          www             # WorldWideWeb HTTP
0 database
ipx             213/udp                         # IPX [RFC1234]
ptp-event       319/udp
ptp-general     320/udp
pawserv         345/tcp                         # Perf Analysis Workbench
zserv           346/tcp                         # Zebra server
rpc2portmap     369/tcp
rpc2portmap     369/udp                         # Coda portmapper
codaauth2       370/tcp
codaauth2       370/udp                         # Coda authentication server
clearcase       371/udp         Clearcase
ldap            389/tcp                 # Lightweight Directory Access Protocol
ldap            389/udp
svrloc          427/tcp                         # Server Location
svrloc          427/udp
https           443/tcp                         # http protocol over TLS/SSL
snpp            444/tcp                         # Simple Network Paging Protocol
microsoft-ds    445/tcp                         # Microsoft Naked CIFS
microsoft-ds    445/udp
kpasswd         464/tcp
kpasswd         464/udp
submissions     465/tcp         ssmtp smtps urd # Submission over TLS [RFC8314]
saft            487/tcp                 # Simple Asynchronous File Transfer
isakmp          500/udp                         # IPSEC key management
rtsp            554/tcp                 # Real Time Stream Control Protocol
rtsp            554/udp
nqs             607/tcp                         # Network Queuing system
asf-rmcp        623/udp         # ASF Remote Management and Control Protocol
qmqp            628/tcp

... 
...

wnn6            22273/tcp                       # wnn6

We can therefore see a list of services, the ports, and the protocols used by the services in question.

c.8 - Domain Name System (DNS)
DNS stands for Domain Name System. It is a system that converts domain names into IP addresses, used by a browser or any network application to access websites or other Internet resources.

Each device connected to the Internet has a unique IP address. DNS servers allow users to use simple domain names, such as datascientest.fr, without having to memorize complex IP addresses.

What is a DNS server?
A DNS server contains a database that associates domain names with their corresponding IP addresses. It acts as an Internet directory, finding the correct IP address for a domain name entered by a user.

Operation of a DNS Server
When a user enters a URL, the DNS request goes through several servers to obtain the correct IP address:

DNS Resolver: receives the initial request from the client and interacts with other servers to find the IP address. Root Servers: provide the list of TLD (top-level domain, e.g., .com, .fr) name servers. TLD Servers: locate the IP address of the second-level domain (e.g., twitter.com) and redirect the request to the authoritative name server. Authoritative Servers: provide the final response with the IP address. They can be masters (primary server with the original records) or slaves (secondary server, a copy of the master for load balancing and redundancy).

Management of hosts without DNS server Entries can be configured locally via the file /etc/hosts. This method works for small networks but is not suitable for large infrastructures.

c.9 - Routing
When two machines are connected point to point, they can communicate directly. To communicate with machines on other networks or on the Internet, routing is necessary.

Routers direct traffic based on the destination address. Each transmission through a router is called a hop.

Default gateway: the router used for all traffic destined for external networks.
Static routing: manually defined via the route command. Useful for small networks.
Dynamic routing: uses protocols such as RIP, EIGRP, and OSPF to automatically determine the best paths.
RIP: chooses the route with the fewest hops.
OSPF: allows defining metrics to prioritize certain routes (bandwidth, latency).
For interconnected networks on the Internet scale, the BGP (Border Gateway Protocol) is used.
c.10 - Internet Protocol version 6 (IPv6)
IPv4 uses 32-bit addresses, which are limited in number. With the increase in connected devices, IPv6 was introduced with 128-bit addresses, ensuring an almost unlimited addressing space.

IPv6 addresses are written in 8 hexadecimal groups separated by colons, for example:
2176:03df:1311:21da::33ad:136
Leading zeros can be omitted, and multiple consecutive groups of zeros can be replaced by :: :
2176:3df:1311:21da::33ad:136
It is possible to have both an IPv4 and an IPv6 address on the same host.
c.11 - The ip command in Linux
The command ip replaces the old command ifconfig and allows you to:

configure network interfaces (assign or remove an IP),
display network settings,
manage routing tables and tunnels.
Basic command example:

ip addr
This command displays the network information and the addresses configured on the server.

ip addr
Output display:

1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 9001 qdisc mq state UP group default qlen 1000
    link/ether 06:43:eb:74:5c:c6 brd ff:ff:ff:ff:ff:ff
    inet 172.31.24.148/20 brd 172.31.31.255 scope global dynamic eth0
       valid_lft 2536sec preferred_lft 2536sec
    inet6 fe80::443:ebff:fe74:5cc6/64 scope link
       valid_lft forever preferred_lft forever
As we saw earlier, the command ip addr (or ip address) returns information about network interfaces such as loopback (lo) and eth0.

loopback (lo) : This is a virtual network device used internally by the operating system. This interface does not interact with the external network and is used for the system to send traffic to itself. By default, the loopback interface is assigned the IP address 127.0.0.1 and the name localhost.

eth0 : This is the main network interface of the server or the wired network card. Wired interfaces are typically named ethX or enpXsY, while wireless interfaces appear as wlanX or wlpXsY, where X and Y depend on the number and type of connected devices.

link/ether : Each network card has a unique physical address called a MAC address. Unlike the IP address (assigned by the network or configured manually), the MAC address is factory-assigned and uniquely identifies the network card on the local network.

inet : Displays the IPv4 address of the interface. Each wired or wireless network interface is assigned a unique address in Internet Protocol version 4.

inet6 : Displays the IPv6 address of the interface. IPv6 was created to increase the number of available addresses and consists of 8 groups of 4 hexadecimal digits, separated by colons. For example, for the interface eth0, an IPv6 address can be :

fe80::443:ebff:fe74:5cc6/64

Although IPv6 is newer, IPv4 remains widely used, and most network interfaces operate with both protocols simultaneously.

You can use ip address or ip addr interchangeably, with addr being simply the abbreviation of address.

To display the information of a specific interface, you can use:

ip addr show dev nom_de_la_carte_reseau
This command allows you to filter the output and display only the information for the desired interface.

Context Setting:

Display information about the device eth0.

To display all information related to the IPv4 protocol for all network devices, we can execute the following command:

ip -4 a
Output display:

1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 9001 qdisc mq state UP group default qlen 1000
    inet 172.31.24.148/20 brd 172.31.31.255 scope global dynamic eth0
       valid_lft 2960sec preferred_lft 2960sec
To display all information related to the IPv6 protocol for all network devices, we can execute the following command:

ip -6 a
Output display:

1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 state UNKNOWN qlen 1000
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 9001 state UP qlen 1000
    inet6 fe80::443:ebff:fe74:5cc6/64 scope link
       valid_lft forever preferred_lft forever
Situation Setup:

Display the information of the eth0 card, filtering those that are specific to IPV4.

ip -4 addr show eth0
Output display:

2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 9001 qdisc mq state UP group default qlen 1000
    inet 172.31.24.148/20 brd 172.31.31.255 scope global dynamic eth0
       valid_lft 2492sec preferred_lft 2492sec
We can do the same for the IPV6 address for the network card lo.

ip -6 addr show dev lo
Output display:

1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
If we now want to remove the IP address from the network interface eth0, we can enter the command:

ip addr del ip_address dev network_card
Context Setting:

Enter the command that allows you to remove the IP address from the eth0 interface with the IP address 172.31.24.148.

Do not run it on your server, as it will simply become unreachable. If your machine has multiple physical cards, you can execute the command while being careful to choose the right card.

ip addr del 172.31.24.148 dev eth0
If we want to add an IP address to a network card, we will simply replace del with add:

ip addr add 172.31.24.2 dev eth0 #we add the IP address 172.31.24.2 on the eth0 card
In order to set up certain configurations, we will need to disable the network card. The network card can also be referred to as network interface or network link. Disabling and enabling a network interface is useful for applying certain changes.

To disable a network card, we can proceed as follows:

sudo ip link set down eth0 #we request that the eth0 link can have a status "down"
Similarly, to activate the network card, we simply replace the state down that we defined with up.

sudo ip link set up eth0

c.12 - Public and Private IP Addresses
There are two main types of IP addresses: public and private.


The Internet is the most well-known public network. To connect to it, it is necessary to have a public IP address.

In IPv4, an IP address ranges from 0.0.0.0 to 255.255.255.255, which represents exactly 3,706,452,992 public IP addresses available worldwide. Thus, when subscribing to an Internet service, the Internet Service Provider (ISP) assigns a unique public IP address to our connection to enable access to the Internet.

The ISP assigns this public IP address to the router. All devices connected to this router then use this same public IP address to communicate with the Internet.

Conversely, when devices on a local network interact with each other (for example, two home computers or a computer and the router), they do not need a public IP address, as the communication occurs internally.

Thus, a router generally has two IP addresses:

A public IP to communicate with the Internet.
A private IP to communicate with local network devices.
That's why routers have at least two network interfaces: one for the public network and one for the private network.

A local network can be considered as a home or professional network, where all devices (computers, smartphones, tablets, etc.) are connected to each other via a router, either by Wi-Fi or by Ethernet cable. When these devices access the Internet, they use the public IP address of the router to interact with the external network.

All IP addresses within a network must be unique :

In a local network, two devices cannot share the same internal IP.
On the Internet, each user or device must have a unique public IP address.
However, two different local networks can use the same range of internal IP addresses without conflict, as they do not interact directly. For example:

The router "A" can have the internal address 192.168.0.254.
The router "B", located in another local network, can have the same internal address 192.168.0.254.
These internal addresses do not conflict as long as the local networks remain separate. As soon as devices communicate with the Internet, it is the public IP address of the router that serves as the unique identifier.

Summary of commands:


Command	Usage
ip addr / ip address	Prints information about all interfaces
ip addr show dev	Prints information about a specific interface
ip -4 a	Displays all information related to IPv4
ip -6 a	Displays all information related to IPv6
ip -4 addr show dev	Displays IPv4 data for the specific device
ip -6 addr show dev	Displays IPv6 data for the specific device
ip addr del  dev	Removes the IP address on a specific device
ip addr add  dev	Adds an IP address to a specific device
sudo ip link set down	Disables a network device
sudo ip link set up	Enables a network device

c.13 - The PING command
The ping command, which uses the ICMP (Internet Control Message Protocol) from the network layer, is primarily used to diagnose a network. It allows checking the connectivity between devices.

When a user sends a ping to an IP address or a hostname, they are asking the target device to confirm its presence on the network. If the latter responds, the ping provides information about the time taken to reach the destination and return (the response time or latency).

The ping command is one of the most basic and universal network commands. It allows you to check if a device is connected to the network.

If a device responds to the ping, it means it is active and reachable at the specified IP address.
If no response is received, the device is inaccessible and no communication is possible.
When a user joins a network but cannot access the Internet, the first step often involves pinging the router to check that access to the local network is functioning correctly.

Similarly, a network administrator can use the ping command to check that an IP address they wish to assign to a device is available before configuring it.

The basic syntax of the command is:

ping [address]
For example, to test connectivity with a public DNS server from Google, you can run:

ping 8.8.8.8
Output display:

PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.
64 bytes from 8.8.8.8: icmp_seq=1 ttl=43 time=1.52 ms
64 bytes from 8.8.8.8: icmp_seq=2 ttl=43 time=1.58 ms
64 bytes from 8.8.8.8: icmp_seq=3 ttl=43 time=1.64 ms
64 bytes from 8.8.8.8: icmp_seq=4 ttl=43 time=1.53 ms
64 bytes from 8.8.8.8: icmp_seq=5 ttl=43 time=1.54 ms
64 bytes from 8.8.8.8: icmp_seq=6 ttl=43 time=1.57 ms
We notice that we have responses from this server. However, the command does not stop by itself; you can press the ctrl+c keys to "cancel".

We can also run the ping command on domain names. Let's execute a ping on google.fr for example:

ping google.fr
Output display:

PING google.fr (142.250.180.3) 56(84) bytes of data.
64 bytes from lhr25s32-in-f3.1e100.net (142.250.180.3): icmp_seq=1 ttl=107 time=1.37 ms
64 bytes from lhr25s32-in-f3.1e100.net (142.250.180.3): icmp_seq=2 ttl=107 time=1.34 ms
64 bytes from lhr25s32-in-f3.1e100.net (142.250.180.3): icmp_seq=3 ttl=107 time=1.46 ms
64 bytes from lhr25s32-in-f3.1e100.net (142.250.180.3): icmp_seq=4 ttl=107 time=1.33 ms
Similarly, if the host we want to reach is not accessible on the network, we will encounter an error:

ping 172.31.24.1
Output display:

PING 172.31.24.1 (172.31.24.1) 56(84) bytes of data.
From 172.31.24.148 icmp_seq=1 Destination Host Unreachable
From 172.31.24.148 icmp_seq=2 Destination Host Unreachable
From 172.31.24.148 icmp_seq=3 Destination Host Unreachable
From 172.31.24.148 icmp_seq=4 Destination Host Unreachable
From 172.31.24.148 icmp_seq=5 Destination Host Unreachable
From 172.31.24.148 icmp_seq=6 Destination Host Unreachable
From 172.31.24.148 icmp_seq=7 Destination Host Unreachable
From 172.31.24.148 icmp_seq=8 Destination Host Unreachable
From 172.31.24.148 icmp_seq=9 Destination Host Unreachabl

c.14 - DHCP
There are two ways to assign an IP address to a device: statically or dynamically.

Static IP addresses: they are permanent and configured directly on the device. The address does not change unless it is modified manually.
Dynamic IP addresses: they are automatically assigned by a router or a DHCP (Dynamic Host Configuration Protocol) server and are not persistent. After a restart, the device may receive a different address from the previous session.
Today, most routers include a DHCP server. When a user connects to a network (via cable or Wi-Fi), they automatically receive an IP address to identify themselves and access the network and the Internet, without manual configuration.

Suppose an user joins a network but does not have Internet access: this may be due to the lack of IP address assignment or an incorrect address.

The following command allows you to request an IP address from a DHCP server for a specific network interface:

sudo dhclient [interface]
The user does not need to specify the router or the DHCP server address, only the network interface for which the address should be assigned.
⚠️ If the interface already has an IP address, the command will return an error. It is then possible to remove the IP address from the interface before executing dhclient to obtain a new address.
Example: To obtain an IP address via DHCP on the interface eth0:

sudo dhclient eth0

c.14 - DNS and the file /etc/resolv.conf
IP addresses (IPv4) consist of 4 octets separated by periods, with values from 0 to 255 in each octet (example: 212.123.56.2).

For humans, memorizing these addresses is difficult. That's why domain names were created: they make it easy to remember a website, like www.facebook.com, instead of the IP address 157.240.221.35.

The DNS (Domain Name System) is the service that translates domain names into IP addresses and vice versa. It allows a user to access a website using a comprehensible name rather than an IP address.

When an administrator sets up a server and a domain name, they associate the domain with the IP address of their server. This information is replicated across all DNS servers in the world.
On the user side, the device must know the addresses of the DNS servers to resolve domain names. Without a configured DNS server, a device will not be able to use domain names and will have to connect directly via IP addresses.
The file /etc/resolv.conf is a text file where the DNS servers to which the device can make requests to resolve domain names are defined.

By default, when the device connects to a router or a network, the DNS is often provided automatically by the router.
Thus, the router acts as the default DNS server for all devices connected to the network.
We can display the contents of the file /etc/resolv.conf to discover its content:

cat /etc/resolv.conf
Output display:

# This file is managed by man:systemd-resolved(8). Do not edit.
#
# This is a dynamic resolv.conf file for connecting local clients to the
# internal DNS stub resolver of systemd-resolved. This file lists all
# configured search domains.
#
# Run "resolvectl status" to see details about the uplink DNS servers
# currently in use.
#
# Third party programs must not access this file directly, but only through the
# symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a different way,
# replace this symlink by a static file or a different symlink.
#
# See man:systemd-resolved.service(8) for details about the supported modes of
# operation for /etc/resolv.conf.
nameserver 127.0.0.53 options edns0 trust-ad search eu-west-2.compute.internal

The syntax for adding a simple DNS server is to simply add one or more lines in the file /etc/resolv.conf with the structure nameserver ip_address.

Let's imagine that we want to add Google as a DNS server on our server, our file /etc/resolv.conf would look like this:

# This file is managed by man:systemd-resolved(8). Do not edit.
#
# This is a dynamic resolv.conf file for connecting local clients to the
# internal DNS stub resolver of systemd-resolved. This file lists all
# configured search domains.
#
# Run "resolvectl status" to see details about the uplink DNS servers
# currently in use.
#
# Third party programs must not access this file directly, but only through the
# symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a different way,
# replace this symlink by a static file or a different symlink.
#
# See man:systemd-resolved.service(8) for details about the supported modes of
# operation for /etc/resolv.conf.
nameserver 127.0.0.53 options edns0 trust-ad search eu-west-2.compute.internal nameserver 8.8.8.8 # Add google as a DNS server

This is how you define a DNS server, ensuring that your device can resolve domain names.

c.15 - The HOST command
The host command is used for DNS resolution. It allows us to find out the IP address of a specific domain name.

For example, to display the IP address of the domain name _facebook.com_, we can execute the host command followed by the URL for which you want to know the IP address:

host facebook.com
Output display:

facebook.com has address 157.240.214.35
facebook.com has IPv6 address 2a03:2880:f158:181:face:b00c:0:25de
facebook.com mail is handled by 10 smtpin.vvv.facebook.com.
As you can see, the output returns both IPv4 and IPv6 addresses and mail servers.

If the user executes the same command with an IP address instead of a domain name, it returns the hostname.

host 157.240.214.35
Output display:

35.214.240.157.in-addr.arpa domain name pointer edge-star-mini-shv-02-lhr8.facebook.com.
We can see that this IP address indeed returns a subdomain of Facebook.

c.16 - The hostname command
The command hostname allows users to temporarily change their system hostname until the next reboot.

The changes that users can make with this command are not persistent and will only last until the next reboot. If the hostname command is executed without parameters, it returns the current hostname of the system.

hostname
Output display:

ip-172-31-24-148

To change the current hostname (without persistence), execute the command with privileges followed by the new hostname you wish to set. In the following example, the hostname _LinuxHint_ is replaced by _Linux-hint-com_.

hostname datascientest
You will not see the change in the current terminal unless you restart the session or change the user. You can change the user with the command sudo -i, to be logged in as the root user.

sudo -i
Output display:

root@datascientest:~#
We can therefore see that the hostname has changed from ip-172-31-24-148 to datascientest. To permanently change the system's hostname, the user must modify two files: /etc/hosts and /etc/hostname. If you check the contents of both files using the cat command, you can see that both files contain the hostname ip-172-31-24-148.

cat /etc/hostname
Output display:

ip-172-31-24-148
The file /etc/hosts contains more information, including the host and the IP address of all interfaces, including the local address of the machine 127.0.0.1 named localhost.

cat /etc/hosts
Output display:

::1 ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
ff02::3 ip6-allhosts
To permanently change the hostname, let's open the file /etc/hostname with privileges using any text editor.

sudo nano /etc/hostname
And let's replace the content with our new hostname datascientest. Once done, save the changes.

The user can also permanently change the hostname using the hostnamectl command:

sudo hostnamectl set-hostname datascientest
Once the command is executed, we can see that the content of the file /etc/hostname has changed.

cat /etc/hostname
Output display:

datascientest

c.17 - Routing
Routing is the mechanism that allows the selection of paths in a network to route data from a sender to one or more recipients.

A routing table is a file or structure that contains information about the paths to take to transfer packets to their destination. It acts like a map used by devices and routers to direct traffic. For example, if we want to reach the site google.fr, the routing table indicates which router (or gateway) the traffic should pass through.

The router used to reach the destination network is called a gateway. The packets that traverse each router until the final destination go through several hops, with the gateway being the first hop. In hop-by-hop routing, each packet uses the routing table of the current hop to reach the next hop.

With the route or ip route commands, it is possible to communicate with different subnets and networks, or even block certain flows by modifying the routing table.

The modern command ip route replaces the old command route, still used by some administrators.

Example to display the configured routes:

ip route
Typical output:

default via 172.31.16.1 dev eth0 proto dhcp src 172.31.24.148 metric 100
172.31.16.0/20 dev eth0 proto kernel scope link src 172.31.24.148
172.31.16.1 dev eth0 proto dhcp scope link src 172.31.24.148 metric 100
In this example:

The default gateway is 172.31.16.1, which is the router used to reach other networks, such as the Internet.
The server automatically knows its local network (172.31.16.0/20) and the route to the gateway.
The command ip r provides exactly the same output:

ip r
default via 172.31.16.1 dev eth0 proto dhcp src 172.31.24.148 metric 100
172.31.16.0/20 dev eth0 proto kernel scope link src 172.31.24.148
172.31.16.1 dev eth0 proto dhcp scope link src 172.31.24.148 metric 100
Suppose now that we are connected to a large network with several subnets. Our router only provides access to the network 172.31.16.0, but we want to access the network 10.0.0.x. If this network is not present in the routing table, we need to add a specific route to this network by specifying the appropriate gateway.

The general syntax for adding a route to a specific network is:

sudo ip route add [network]/[mask] via [gateway] dev [interface]
Example to add access to the network 10.0.0.0/24 via the gateway 172.31.16.1 on the interface eth0:

sudo ip route add 10.0.0.0/24 via 172.31.16.1 dev eth0
This command allows the server to send packets destined for the 10.0.0.x network through the specified gateway:

sudo ip route add default via 172.31.16.1 # here 172.31.16.1 is our default gateway
If we want to apply the default gateway for a specific interface, we use the following syntax:

sudo ip route add default dev eth0 # we associate the default gateway with our device (device) eth0
To remove a default gateway, we can execute the following command.

sudo ip route delete default
There are different types of routing: static, dynamic, and default. All are explained in detail in the second part of this course.

  Don't hesitate to check the command manual page available at this address.

c.18 - The netcat command
All computers or devices connected to a network are identified by an IP address. This address is necessary to locate and reach devices within a network.

In addition to the IP address, each device has ports at the software level. You can imagine a computer like a house:

The IP is the address of the house.
The ports are the different doors through which traffic can enter or exit.
A computer system has 65,536 ports in total, although most remain unused. Each port can serve a specific service. For example:

Port 80 is used by the HTTP protocol.
Port 443 is used by HTTPS, the secure version of HTTP.
The user can modify these ports and make a service accessible on a different port. For example, it is common to change the 22 port of SSH to avoid automated scans targeting default ports.

It is therefore essential to know how to check which ports are open, closed, or sending or receiving traffic. This practice is useful for:

Diagnose network issues.
Check security before an attacker attempts to exploit a vulnerability.
Tool: Netcat (nc)
The Netcat tool allows you to test port openings and create simple network connections.

Basic Syntax :
nc [<options>] <host> <port>
<host> : IP address or hostname of the target.
<port> : port number or service name.
Operating modes :
Connection mode

Netcat works as a client.
Requires providing the parameters <host> and <port>.
Listening mode

Netcat functions as a server.
If <host> is omitted, Netcat listens on all available addresses for the specified port.
By default, without any additional options, Netcat attempts to initiate a TCP connection to the provided host and port.

Netcat (nc) Command Options

The table below describes the common options for the nc command:


Option	Mode	Description
-4	Protocol	Use IPv4 only.
-6	Protocol	Use IPv6 only.
-U  --unixsock	Protocol	Use Unix domain sockets.
-u  --udp	Protocol	Use UDP connection.
-g	Connection mode	Set hops for loose source routing in IPv4. Hops are IP addresses or hostnames.
-p   --source-port	Connection mode	Bind the Netcat source port to the specified port.
-s  --source  	Connection mode	Bind the Netcat host to the specified host.
-l --listen	Listening mode	Listen for connections instead of using connection mode.
-k --keep-open	Listening mode	Keeps the connection open for multiple simultaneous connections.
-v --verbose	Output	Sets the verbosity level. Use multiple times to increase verbosity.
-z	Output	Report the connection status without establishing a connection.
To have a more complete list, refer to the manual of the netcat command.

man netcat
To install Netcat on Debian-based Linux distributions, run the following command:

sudo apt install netcat -y # the -y flag allows the command to execute without confirmation
Once installed, run nc (or netcat) followed by the options -zvn, the IP address, and the port to scan. Let's execute the command to check port _22_ (ssh) of our local machine (127.0.0.1):

nc -zvn 127.0.0.1 22
Output display:

Connection to 127.0.0.1 22 port [tcp/*] succeeded!
As you can see in the output, port 22 is open. We can also specify many ports to scan. In the following example, ports 21, 443, and 80 are checked.

nc -zvn 127.0.0.1 21 443 80
Output display:

nc: connect to 127.0.0.1 port 21 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 443 (tcp) failed: Connection refused
Connection to 127.0.0.1 80 port (tcp) failed: Connection refused
Port 80 is therefore open while ports 21 and 443 are closed. By implementing a hyphen, you can specify a range of ports. Let's analyze, for example, all ports between 80 and 443.

nc -z -v -w 5 datascientest.fr 80-443
Output display:

Connection to 127.0.0.1 80 port [tcp/*] succeeded!
nc: connect to 127.0.0.1 port 81 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 82 (tcp) failed: Connection refused
nc: connect to 127.0.0.1 port 83 (tcp) failed: Connection refused
...
...
nc: connect to 127.0.0.1 port 443 [tcp/*] succeeded!

c.19 - Nmap
Nmap (Network Mapper) is the most widely used tool for scanning ports and detecting vulnerabilities on systems or networks. It also allows for discovering hosts to map and analyze networks.

Using the NSE (Nmap Scripting Engine), Nmap can also detect security flaws or vulnerabilities on a target. This allows for issues to be fixed before an attacker can exploit them.

During a port scan with Nmap, each port can be in one of six states:

Open : The port is open and a service is active and listening.
Closed : The port is closed and does not accept any connections.
Filtered : The port is blocked by a firewall or filtering device, Nmap cannot determine its actual state.
Not filtered : The port is not filtered, but Nmap could not determine if it is open or closed.
Open|filtered : Nmap cannot distinguish whether the port is open or filtered.
Closed|filtered : Nmap cannot distinguish whether the port is closed or filtered.
We can install nmap with the following command:

sudo apt install nmap -y
To perform a basic analysis on google.fr, let's execute the following command:

nmap google.fr
Output display:

Starting Nmap 7.80 ( https://nmap.org ) at 2022-11-21 06:51 UTC
Nmap scan report for google.fr (142.250.178.3)
Host is up (0.0045s latency).
Other addresses for google.fr (not scanned): 2a00:1450:4009:821::2003
rDNS record for 142.250.178.3: lhr48s27-in-f3.1e100.net
Not shown: 998 filtered ports
PORT    STATE SERVICE
80/tcp  open  http
443/tcp open  https

Nmap done: 1 IP address (1 host up) scanned in 4.47 seconds
Nmap found that ports and protocols 80, 443 are open with services listening. All are web-related protocols: http, https. We can also specify IP addresses instead of domain names or hosts:

nmap 127.0.0.1
Output display:

Starting Nmap 7.80 ( https://nmap.org ) at 2022-11-21 06:53 UTC
Nmap scan report for localhost (127.0.0.1)
Host is up (0.00058s latency).
Not shown: 996 closed ports
PORT     STATE SERVICE
22/tcp   open  ssh
80/tcp   open  http
3306/tcp open  mysql
8080/tcp open  http-proxy
Nmap can discover all active hosts within a network. To discover the hosts, run nmap followed by the flags -sP in which all devices connected to the network 172.31.24.148/20 are discovered.

nmap -sP 172.31.24.148/20
Output display:

Starting Nmap 7.80 ( https://nmap.org ) at 2022-11-21 06:55 UTC
Nmap scan report for ip-172-31-24-148.eu-west-2.compute.internal (172.31.24.148)
Host is up (0.00038s latency).
Nmap done: 4096 IP addresses (1 host up) scanned in 103.73 seconds
As you can see, a host or a device has been discovered, and it is our server. We can also use a wildcard character * called wildcard to find all IP addresses belonging to the network.

nmap -sP 172.31.24.*
To analyze a specific port to check if it is open or closed, we use the -p (port) indicator followed by the port and the URL or host to analyze.

Context Setting:

Scan the port 80 of the site datascientest.fr :

nmap -p 80 datascientest.fr
Output display:

Starting Nmap 7.80 ( https://nmap.org ) at 2022-11-21 07:04 UTC
Nmap scan report for datascientest.fr (52.209.254.47)
Host is up (0.012s latency).
rDNS record for 52.209.254.47: ec2-52-209-254-47.eu-west-1.compute.amazonaws.com

PORT   STATE SERVICE
80/tcp open  http

Nmap done: 1 IP address (1 host up) scanned in 0.07 seconds
We can also specify a range of ports to scan:

nmap -p 21-25 127.0.0.1 # We are scanning from port 21 to port 25 of our local machine
nmap -p 21-25 127.0.0.1 # We are scanning from port 21 to port 25 of our local machine
Output display:

Starting Nmap 7.80 ( https://nmap.org ) at 2022-11-21 07:08 UTC
Nmap scan report for localhost (127.0.0.1)
Host is up (0.00013s latency).

PORT   STATE  SERVICE
21/tcp closed ftp
22/tcp open   ssh
23/tcp closed telnet
24/tcp closed priv-mail
25/tcp closed smtp

Nmap done: 1 IP address (1 host up) scanned in 0.04 seconds


c.20 - IPTABLES
The command iptables allows you to configure the tables of the firewall integrated into the Linux kernel, as well as the chains and rules they contain. It is used to control and filter incoming or outgoing network traffic on a Linux system.

The iptables module only manages IPv4 traffic. To manage firewall rules on IPv6 connections, you must use ip6tables, which has an identical syntax to that of iptables.

List the current rules

Servers do not implement any restrictions by default; however, we can check the current iptables rules using the command:

sudo iptables -L
We receive as output a list of three strings, input, forward, and output :

Chain INPUT (policy DROP) # input chain
target     prot opt source               destination
ufw-before-logging-input  all  --  anywhere             anywhere
ufw-before-input  all  --  anywhere             anywhere
ufw-after-input  all  --  anywhere             anywhere
ufw-after-logging-input  all  --  anywhere             anywhere
ufw-reject-input  all  --  anywhere             anywhere
ufw-track-input  all  --  anywhere             anywhere

Chain FORWARD (policy DROP)  # forward chain
target     prot opt source               destination
ufw-before-logging-forward  all  --  anywhere             anywhere
ufw-before-forward  all  --  anywhere             anywhere
ufw-after-forward  all  --  anywhere             anywhere
ufw-after-logging-forward  all  --  anywhere             anywhere
ufw-reject-forward  all  --  anywhere             anywhere
ufw-track-forward  all  --  anywhere             anywhere

Chain OUTPUT (policy ACCEPT)  # output chain
target     prot opt source               destination
ufw-before-logging-output  all  --  anywhere             anywhere
ufw-before-output  all  --  anywhere             anywhere
ufw-after-output  all  --  anywhere             anywhere
ufw-after-logging-output  all  --  anywhere             anywhere
ufw-reject-output  all  --  anywhere             anywhere
ufw-track-output  all  --  anywhere             anywhere
The chains in iptables define what type of traffic the rules apply to:

INPUT : all connections incoming to our server.
OUTPUT : all traffic outgoing from the server.
FORWARD : the connections passing through the server (for example for a router or a gateway).
Each chain has a default policy, which indicates how to handle traffic that does not match any rules. By default, this policy is set to ACCEPT.

Adding Rules
A firewall can be configured using two approaches:

Blacklist strategy: accept all traffic by default and only block what is undesirable through specific rules.
Whitelist strategy (recommended): block all traffic by default and only allow what is necessary. This approach is more secure as it prevents unwanted connections before they attempt to access the server.
To use iptables, we start by adding rules to allow the necessary incoming traffic for the services we want to expose. iptables can track the state of connections, which allows, for example, to permit the continuity of already established connections with the command:

sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT # allow the creation of rules in the INPUT chain for all already established connections
We can verify that the rule has been added by running the command sudo iptables -L. Then, let's allow traffic to a specific port to enable SSH connections for example.

sudo iptables -A INPUT -p tcp --dport ssh -j ACCEPT # authorize in the INPUT chain a rule that allows port 22 in tcp
The SSH protocol uses port 22 by default. The iptables command can therefore be used to allow incoming traffic on this port. The same syntax can be applied for any other port or service that we want to allow access to.

A few points to note:

The flag -A means append, which means to add a rule at the end of the existing rules in the chain.
To view all available flags and options in iptables, you can use:
iptables --help
Output display:

iptables v1.8.4
Usage: iptables -[ACD] chain rule-specification [options] iptables -I chain [rulenum] rule-specification [options] iptables -R chain rulenum rule-specification [options] iptables -D chain rulenum [options] iptables -[LS] [chain [rulenum]] [options] iptables -[FZ] [chain] [options] iptables -[NX] chain iptables -E old-chain-name new-chain-name iptables -P chain target [options] iptables -h (print this help information)

Commands: Either long or short options are allowed. --append -A chain Append to chain --check -C chain Check for the existence of a rule --delete -D chain Delete matching rule from chain --delete -D chain rulenum Delete rule rulenum (1 = first) from chain --insert -I chain [rulenum] Insert in chain as rulenum (default 1=first) --replace -R chain rulenum Replace rule rulenum (1 = first) in chain --list -L [chain [rulenum]] List the rules in a chain or all chains --list-rules -S [chain [rulenum]] Print the rules in a chain or all chains --flush -F [chain] Delete all rules in chain or all chains --zero -Z [chain [rulenum]] Zero counters in chain or all chains --new -N chain Create a new user-defined chain --delete-chain -X [chain] Delete a user-defined chain --policy -P chain target Change policy on chain to target --rename-chain -E old-chain new-chain Change chain name, (moving any references) Options: --ipv4 -4 Nothing (line is ignored by ip6tables-restore) --ipv6 -6 Error (line is ignored by iptables-restore) [!] --protocol -p proto protocol: by number or name, eg. tcp' [!] --source -s address[/mask][...] source specification [!] --destination -d address[/mask][...] destination specification [!] --in-interface -i input name[+] network interface name ([+] for wildcard) --jump -j target target for rule (may load target extension) --goto -g chain jump to chain with no return --match -m match extended match (may load extension) --numeric -n numeric output of addresses and ports [!] --out-interface -o output name[+] network interface name ([+] for wildcard) --table -t table table to manipulate (default:filter') --verbose -v verbose mode --wait -w [seconds] maximum wait to acquire xtables lock before give up --wait-interval -W [usecs] wait time to try to acquire xtables lock default is 1 second --line-numbers print line numbers when listing --exact -x expand numbers (display exact values) [!] --fragment -f match second or further fragments only --modprobe= try to insert modules using this command --set-counters PKTS BYTES set the counter during insert/append [!] --version -V print package version.

To enable access to an HTTP web server, let's use the following command:

sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
After adding all the allowed rules we need, let's modify the entry strategy to deny all incoming packets by default.

  Attention : Changing the default policy will only allow explicitly accepted connections. Make sure you have enabled at least SSH before changing the default rule. Otherwise, you risk losing access to your server via SSH.
To set the default policy of the INPUT chain to block all unauthorized incoming traffic:

sudo iptables -P INPUT DROP
The same policies can be applied to the other chains (OUTPUT, FORWARD) using DROP or ACCEPT according to your needs.

Recording and restoring rules
If the server restarts, the iptables rules set in the session would be lost. To make them persistent, you need to use the iptables-persistent package:

sudo apt-get install iptables-persistent -y
During the installation, the system will ask you if you want to save the current rules for IPv4 and IPv6. Simply select Yes for both and press Enter.

Thus, your iptables rules will be automatically restored upon server restart.

Once installed, we will be able to record the rules in IPV4 and IPV6 with separate commands. For the IPV4 rules, the command is:

sudo iptables-save | sudo tee /etc/iptables/rules.v4
Output display:

# Generated by iptables-save v1.8.4 on Mon Nov 21 11:10:15 2022
*filter
:INPUT DROP [9:448]
:FORWARD DROP [0:0]
...
...
-A ufw-user-limit -j REJECT --reject-with icmp-port-unreachable
-A ufw-user-limit-accept -j ACCEPT
COMMIT
# Completed on Mon Nov 21 11:10:15 2022
For the IPV6 rules:

sudo ip6tables-save | sudo tee /etc/iptables/rules.v6
In accordance with the basic operation of a firewall, the rules are interpreted in the order in which they appear on each chain. This means that the order of the rules is important for filtering to work correctly.

The classic addition of new rules is done at the end of the list.
If you want to insert a rule at a specific position in the list, you can use the command :
sudo iptables -I <CHAIN> <NUMBER> <RULE>
Where :

<CHAIN> corresponds to the chain on which to apply the rule (INPUT, OUTPUT, FORWARD).
<NUMBER> is the position in the list where the rule will be inserted (1 being the first position).
<RULE> is the rule you wish to apply (e.g., allow a port or block an IP).
Example: to allow SSH traffic on port 22 and have this rule evaluated before other rules, one could write:

sudo iptables -I INPUT 1 -p tcp --dport 22 -j ACCEPT
Thus, the SSH rule will be processed before the other rules in the INPUT chain.

To find out the index number of our rules, let's use the following command:

sudo iptables -L --line-numbers
Output display:

Chain INPUT (policy DROP)
 num target prot opt source   destination
 1   ACCEPT all  --  anywhere anywhere ctstate RELATED,ESTABLISHED
 2   ACCEPT tcp  --  anywhere anywhere , dpt:ssh
 3   ACCEPT tcp  --  anywhere anywhere tcp dpt:http
The number at the beginning of each line of the rule indicates the position in the string. To insert a new rule above an existing rule, simply use the index number of that rule.

Example: to insert a rule at the top of the INPUT chain to allow HTTP traffic on port 80:
sudo iptables -I INPUT 1 -p tcp --dport 80 -j ACCEPT
Rule Suppression
To delete an existing rule from a chain, use the -D parameter with the index number:

Example: remove the second rule from the INPUT string:
sudo iptables -D INPUT 2
It is also possible to flush all rules of a specific chain or of all tables with the -F flag (flush):

⚠️ Before clearing a chain, make sure that the default policy is set to ACCEPT to avoid blocking any legitimate traffic:

sudo iptables -P INPUT ACCEPT
Empty only the INPUT string:
sudo iptables -F INPUT
Clear all iptables rules:
sudo iptables -F
Attention: a server with empty iptables may be vulnerable to attacks. Remember to save your rules before deleting them if you want to be able to restore them.

c.21 - UFW (Uncomplicated Firewall)
Firewalls are defensive tools that allow for:

Block or allow traffic.
Close or open ports.
Whitelist or blacklist traffic sources.
UFW is a simplified interface for iptables that makes creating and managing firewall rules much easier.

To install UFW on a Debian/Ubuntu based system:
sudo apt install ufw -y
After installing UFW, enable it by running the following command:

sudo ufw enable
Output display:

Command may disrupt existing ssh connections. Proceed with operation (y|n)? y
Firewall is active and enabled on system startup
We can now check the status with the command:

sudo ufw status
Output display:

Status: active
As we can see, the firewall is active and enabled.

The following command asks UFW to deny (block) all incoming traffic by default:

Do not apply, as we are in this course connected via ssh, which would prevent us from connecting to our machine. We can apply this only if we are on the local machine.

sudo ufw default deny incoming
Then, we can add exceptions to allow incoming traffic through ports 80 (http) and https (443). As we can see, we can specify the ports or protocols with numeric values or by their name.

sudo ufw allow 80 # we could have written http instead of 80 for the same result
sudo ufw allow https
Let's run the command again to check if the rules have been correctly added:

sudo ufw status
Output display:

Status: active
To Action From -- ------ ---- 80 ALLOW Anywhere 443/tcp ALLOW Anywhere 80 (v6) ALLOW Anywhere (v6) 443/tcp (v6) ALLOW Anywhere (v6)

We can delete a specific rule using the delete argument followed by the rule to be deleted:

sudo ufw delete allow 80
Output display:

Rule deleted
Rule deleted (v6)
If we check the status of our rules again:

sudo ufw status
Output display:

Status: active
To Action From -- ------ ---- 443/tcp ALLOW Anywhere 443/tcp (v6) ALLOW Anywhere (v6)

We can confirm that this rule has been successfully removed. We can thus implement a restrictive and very defensive firewall. Deny all incoming traffic and add the exceptions that we wish to allow.

We can also close ports and block certain IP addresses:

 sudo ufw deny 25/tcp # blocks access on port 25 in tcp
 sudo ufw deny from 203.5.1.43 # blocks access from host 203.5.1.43
 sudo ufw deny from 1.1.1.2 to any port 22 # blocks access from host 1.1.1.2 from any source port to port 22 on our server
Suppose we want to open ports and allow the IP address with ufw and add a comment. We have the comment option. The syntax is as follows to open TCP ports 80 and 443:

sudo ufw allow 80/tcp comment 'allow access for port 80 in TCP'
sudo ufw allow 1194/udp comment 'OpenVPN server' # another example that allows opening port 1194 in UDP
c.22 - Netstat
Netstat (Network Statistics) is a command to monitor network activity. It can show us all connections and their status, as well as their protocol, port, and destination or source address. To install netstat, we can execute the following command:

sudo apt install net-tools -y
If netstat is run without any options, the output looks like this:

netstat
Output display:

roto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 localhost:http-alt      localhost:55594         ESTABLISHED
tcp        0      0 localhost:55594         localhost:http-alt      ESTABLISHED
tcp        0      0 ip-172-31-24-148.:48130 ec2-34-253-229-19.:http TIME_WAIT
tcp        0    164 ip-172-31-24-148.eu:ssh ec2-3-8-37-29.eu-:21853 ESTABLISHED
Active UNIX domain sockets (w/o servers)
Proto RefCnt Flags       Type       State         I-Node   Path
unix  2      [ ]         DGRAM                    236003   /run/user/1000/systemd/notify
unix  3      [ ]         DGRAM      CONNECTED     546      /run/systemd/notify
unix  2      [ ]         DGRAM                    563      /run/systemd/journal/syslog
unix  11     [ ]         DGRAM      CONNECTED     573      /run/systemd/journal/dev-log
unix  9      [ ]         DGRAM      CONNECTED     577      /run/systemd/journal/socket
unix  3      [ ]         STREAM     CONNECTED     16018
unix  3      [ ]         STREAM     CONNECTED     22766    /run/dbus/system_bus_socket
unix  3      [ ]         STREAM     CONNECTED     22139    /run/systemd/journal/stdout
unix  3      [ ]         DGRAM      CONNECTED     20099
unix  3      [ ]         STREAM     CONNECTED     236007
unix  3      [ ]         STREAM     CONNECTED     24466
unix  2      [ ]         DGRAM      CONNECTED     21215
unix  2      [ ]         DGRAM      CONNECTED     15427
As you can see in the previous output, the first column displays the protocol (in this case TCP), the fourth column (local address) shows the local IP address and the local open port. The fifth column (Foreign Address) displays the hosts of the devices or servers we are connected to. The last column shows the state of the connection. In this case, the connections are established (active).

We can ask netstat to display the remote hosts we are connected to by IP address instead of the hostname by adding the n flag:

netstat -n
Output display:

Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 127.0.0.1:8080          127.0.0.1:55594         ESTABLISHED
tcp        0      0 127.0.0.1:55594         127.0.0.1:8080          ESTABLISHED
tcp        0    164 172.31.24.148:22        3.8.37.29:21853         ESTABLISHED
By adding the -t flag, we can ask netstat to display only TCP connections:

netstat -t
Output display:

Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 localhost:http-alt      localhost:55594         ESTABLISHED
tcp        0      0 localhost:55594         localhost:http-alt      ESTABLISHED
tcp        0    164 ip-172-31-24-148.eu:ssh ec2-3-8-37-29.eu-:21853 ESTABLISHED
With the -p flag, we can ask netstat to display a new column including the PID and the name of the program that is generating the connection. In the following example, the PID is 3784, all belonging to the web browser Firefox:

netstat -p
Output display:

unix  2      [ ]         DGRAM                    236003   21334/systemd        /run/user/1000/systemd/notify
unix  3      [ ]         DGRAM      CONNECTED     546      -                    /run/systemd/notify
unix  2      [ ]         DGRAM                    563      -                    /run/systemd/journal/syslog
unix  10     [ ]         DGRAM      CONNECTED     573      -                    /run/systemd/journal/dev-log
unix  9      [ ]         DGRAM      CONNECTED     577      -                    /run/systemd/journal/socket
unix  3      [ ]         STREAM     CONNECTED     16018    -
unix  3      [ ]         STREAM     CONNECTED     22766    -                    /run/dbus/system_bus_socket
unix  3      [ ]         STREAM     CONNECTED     22139    -                    /run/systemd/journal/stdout
unix  3      [ ]         DGRAM      CONNECTED     20099    -
unix  3      [ ]         STREAM     CONNECTED     236007   21334/systemd
unix  3      [ ]         STREAM     CONNECTED     24466    -
unix  2      [ ]         DGRAM      CONNECTED     21215    -
unix  2      [ ]         DGRAM      CONNECTED     15427    -
unix  3      [ ]         STREAM     CONNECTED     16609    -                    /run/systemd/journal/stdout
unix  3      [ ]         STREAM     CONNECTED     258346   -
unix  3      [ ]         STREAM     CONNECTED     19959    -                    /run/systemd/journal/stdout
unix  3      [ ]         STREAM     CONNECTED     26269    -                    /run/systemd/journal/stdout
We can also combine options with the netstat command.

Situation setup:

You want to check the UDP and TCP connections, along with the PIDs of the processes and all the remote hosts we are connected to. What command should be used?

To get the list of options, we can consult the help of netstat with the command:

netstat -h # or netstat --help
Output display:

usage: netstat [-vWeenNcCF] [<Af>] -r         netstat {-V|--version|-h|--help}
       netstat [-vWnNcaeol] [<Socket> ...]
       netstat { [-vWeenNac] -i | [-cnNe] -M | -s [-6tuw] }

        -r, --route              display routing table
        -i, --interfaces         display interface table
        -g, --groups             display multicast group memberships
        -s, --statistics         display networking statistics (like SNMP)
        -M, --masquerade         display masqueraded connections

        -v, --verbose            be verbose
        -W, --wide               don't truncate IP addresses
        -n, --numeric            don't resolve names
        --numeric-hosts          don't resolve host names
        --numeric-ports          don't resolve port names
        --numeric-users          don't resolve user names
        -N, --symbolic           resolve hardware names
        -e, --extend             display other/more information
        -p, --programs           display PID/Program name for sockets
        -o, --timers             display timers
        -c, --continuous         continuous listing

        -l, --listening          display listening server sockets
        -a, --all                display all sockets (default: connected)
        -F, --fib                display Forwarding Information Base (default)
        -C, --cache              display routing cache instead of FIB
        -Z, --context            display SELinux security context for sockets

  <Socket>={-t|--tcp} {-u|--udp} {-U|--udplite} {-S|--sctp} {-w|--raw}
           {-x|--unix} --ax25 --ipx --netrom
  <AF>=Use '-6|-4' or '-A <af>' or '--<af>'; default: inet
  List of possible address families (which support routing):
    inet (DARPA Internet) inet6 (IPv6) ax25 (AMPR AX.25)
    netrom (AMPR NET/ROM) ipx (Novell IPX) ddp (Appletalk DDP)
    x25 (CCITT X.25)
We can therefore execute the command:

netstat -tupn
Output display:

Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 127.0.0.1:8080          127.0.0.1:55594         ESTABLISHED -
tcp        0      0 127.0.0.1:55594         127.0.0.1:8080          ESTABLISHED -
tcp        0    308 172.31.24.148:22        3.8.37.29:21853         ESTABLISHED -

c.23 - SSH Presentation
SSH (Secure Shell)
SSH is a secure protocol mainly used to remotely control Linux servers via a text interface. It allows executing commands, configuring services, and managing systems remotely in a secure manner.

Meaning : SSH = Secure Shell
Function : Secure transmission of commands and data between a client and a remote server.
Operation of SSH
Remote shell session

Once connected via SSH, the user obtains a shell session.
All commands entered in the local terminal are transmitted via an encrypted SSH tunnel and executed on the remote server.
Client-server model

The SSH server runs an SSH daemon that listens for connections on a specific network port (by default, port 22).
The server authenticates connection requests and creates the appropriate environment for the user if the authentication information is correct.
The SSH client is the software on the local computer that allows connecting to the remote server with a username and the necessary credentials.

SSH Authentication Methods
Password

Simple but less secure.
Encryption enabled, but not recommended for sensitive environments.
SSH Keys (recommended)

Very secure.
A pair of keys: public key + private key.

The public key can be shared.
The private key must remain strictly confidential.
SSH Key Authentication Process :

The public key is copied to the server in ~/.ssh/authorized_keys.
The client informs the server that it wishes to use the public key for authentication.
The server generates an encrypted message with the public key and sends it to the client.
The client decrypts the message with its private key, combines the random string with the session ID, and generates an MD5 hash that it sends back to the server.
The server compares the received hash with its expected value; if they match, the client is authenticated.
⚠️ MD5 (Message-Digest Algorithm) is used to verify the integrity and authenticity of messages.

Generating an SSH Key Pair
To create a public and private key pair on your local machine:

Common algorithms: RSA, ECDSA, ED25519.
RSA is generally preferred and often the default.
Command type to generate an RSA key:

ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
-t rsa : key type
-b 4096 : key length (4096 bits)
-C : comment or email to identify the key
To generate an RSA key pair on your local computer, run:

ssh-keygen
Output display:

Generating public/private rsa key pair. Enter file in which to save the key (/home/ubuntu/.ssh/id_rsa):
SSH Key Management
After generating an RSA key pair with ssh-keygen, you get two files in the hidden .ssh directory of your user:

~/.ssh/id_rsa : private key, to be kept strictly confidential.
~/.ssh/id_rsa.pub : public key, can be shared freely.
When generating the key, you can choose the storage location (press ENTER to accept the default value). Then, you can set a passphrase to encrypt your private key:

Enter passphrase (empty for no passphrase): 
Enter same passphrase again:
The passphrase protects your private key.
Each use of the key will require entering this passphrase.
If someone obtains your private key but not the passphrase, they will not be able to connect via SSH.
Example of output:

Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is: 8c:e9:7c:fa:bf:c4:e5:9c:c9:b8:60:1f:fe:1c:d3:8a root@here
The key's randomart image ...
ssh-keygen -p
Process:

Select the key file to modify (default ~/.ssh/id_rsa) :
Enter file in which the key is (/root/.ssh/id_rsa):
Enter the old passphrase :
Enter old passphrase:
Enter a new passphrase or press ENTER to delete:
Enter new passphrase (empty for no passphrase): 
Enter same passphrase again:
⚠️ If you have lost the old passphrase, you will not be able to recover it and will need to generate a new key pair.

Each SSH key pair has a unique cryptographic fingerprint, useful for identifying the key.

To display the fingerprint:

ssh-keygen -l
Select the key file to verify (press ENTER if it is the default file).
The output will include:

key length in bits
fingerprint
associated account and host
algorithm used
Example:

Enter file in which the key is (/root/.ssh/id_rsa):
If this is the correct location of the key, leave it as default; otherwise, enter the location provided when the key was created. You will receive a string containing the length in bits of the key, the fingerprint, the account, and the host for which it was created, as well as the algorithm used.

Output display:

2048 SHA256:45Vxp8rWnac70jKEVo9mZNKI5SxxyYOUJYPKFsrdaeU ubuntu@172.19.78.203 (RSA)
To establish an SSH connection, we need to add a user on the remote machine to use as login credentials.

On your machine, you can connect to the client1 container to create a user there.

vagrant ssh client1
Output display:

Welcome to Ubuntu 20.04.5 LTS (GNU/Linux 5.15.0-1019-aws x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

This system has been minimized by removing packages and content that are
not required on a system that users do not log into.

To restore this content, you can run the 'unminimize' command.
Last login: Wed Nov 30 18:05:54 2022 from 172.17.0.1
Create your user utilisateur-ssh:

sudo useradd -m -d /home/utilisateur-ssh utilisateur-ssh # Adds the user by creating their home directory
sudo passwd utilisateur-ssh # Sets the password for the user utilisateur-ssh
Output display:

New password:
Define a password and enter the same password again. We will set Datascientest2022@ as the password. Also, check the IP address to use to connect to this container.

ip addr
Output display:

156: eth1@if157: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:c0:a8:0a:0b brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 192.168.10.11/24 brd 192.168.10.255 scope global eth1
       valid_lft forever preferred_lft forever
You have several network cards available, but the IP address to use here is 192.168.10.11.

Now, disconnect from this machine and connect this time via SSH without using Vagrant.

exit
Output display:

logout
Connection to 127.0.0.1 closed.
Connect now using this password. The syntax is ssh user@addressIO

ssh user-ssh@192.168.10.11
Output display:

The authenticity of host '192.168.10.11 (192.168.10.11)' can't be established.
ECDSA key fingerprint is SHA256:UFy40RBLiCDfoRwV05JFzQzwLawZTn017o9hUvF2El0.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '192.168.10.11' (ECDSA) to the list of known hosts.
The output asks you if you want to continue, simply enter yes. Output display:

user-ssh@192.168.10.11's password:
Please enter the password set for the user.

To set up a passwordless connection between the server and the client, you will need to generate a key pair as mentioned earlier and copy the public key to the server so that the private key can authenticate you on the specified server.

ssh-keygen
You will validate the default location, and you will not set a password.

Generating public/private rsa key pair.
Enter file in which to save the key (/home/ubuntu/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/ubuntu/.ssh/id_rsa
Your public key has been saved in /home/ubuntu/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:5jl4y13BsRiwVfja4vnFKcMDJn3JvBE7I0+Ey9UrjKI ubuntu@ip-172-31-25-195
The key's randomart image is:
+---[RSA 3072]----+
|        . .o.    |
|         +.. .   |
|        . o.= .  |
|         o %.* . |
|        S Xo^ .  |
|       = =oB.O . |
|      E =. oO +  |
|       o +o. =   |
|        o ...    |
+----[SHA256]-----+
You can now use the command that will serve to copy the public key to the host client1, and then you will need to enter your password to validate the key copy:

ssh-copy-id ssh-user@192.168.10.11
Output display:

/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/home/ubuntu/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
utilisateur-ssh@192.168.10.11's password:

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh 'user-ssh@192.168.10.11'"
and check to make sure that only the key(s) you wanted were added.
You can now disconnect from the container and restart an SSH connection to verify that it does not ask you for a password:

exit
ssh user-ssh@192.168.10.11
Output display:

Welcome to Ubuntu 20.04.5 LTS (GNU/Linux 5.15.0-1019-aws x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

Este sistema ha sido minimizado al eliminar paquetes y contenido que no son necesarios en un sistema al que los usuarios no inician sesión.

To restore this content, you can run the 'unminimize' command.
$ 
You can therefore confirm that no password is being requested.